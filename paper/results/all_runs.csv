workload,policy,policy_description,cpp_file_path,cache_hit_rate,score
astar,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.45454223305787467,0.4168733894766456
astar,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.3573547794394494,0.37579227983384317
astar,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.38901773944350737,0.4332826897688782
astar,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.03709567109384967,0.11453256801665043
astar,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.4110201774653078,0.34660260743866517
astar,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.33821173935846005,0.37559793796024865
lbm,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.43985783443540666,0.4168733894766456
lbm,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.27289983516244354,0.37579227983384317
lbm,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.32972240516582263,0.4332826897688782
lbm,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.011593643367720617,0.11453256801665043
lbm,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.19358477211349756,0.34660260743866517
lbm,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.2615846099982021,0.37559793796024865
mcf,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.4074020886631043,0.4168733894766456
mcf,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.5087725688923012,0.37579227983384317
mcf,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.5230175409101099,0.4332826897688782
mcf,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.515161598323247,0.11453256801665043
mcf,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.5200312710592792,0.34660260743866517
mcf,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.524743749964974,0.37559793796024865
milc,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.3219114100958022,0.4168733894766456
milc,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.06456693483565899,0.37579227983384317
milc,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.23460321368313578,0.4332826897688782
milc,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.00026430697263517673,0.11453256801665043
milc,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.14627399581453615,0.34660260743866517
milc,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.054986712238499026,0.37559793796024865
omnetpp,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.4606533811310401,0.4168733894766456
omnetpp,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.6753672808393627,0.37579227983384317
omnetpp,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.6900525496418154,0.4332826897688782
omnetpp,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.008547620325799737,0.11453256801665043
omnetpp,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.4621028207407054,0.34660260743866517
omnetpp,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.698462878241108,0.37559793796024865
all,LRU,Least Recently Used (LRU) replacement policy evicts the cache line that has not been accessed for the longest time. It assumes temporal locality—recently used data is more likely to be used again. This simple stack-based heuristic is hardware-friendly but can perform poorly under non-recurring access patterns or streaming workloads.,ChampSim_CRC2/champ_repl_pol/lru.cc,0.4168733894766456,0.4168733894766456
all,Hawkeye,"Hawkeye is a predictive replacement policy that leverages Belady's MIN algorithm as an oracle during training phases. It classifies memory accesses as cache-friendly or cache-averse using past reuse behavior. Hawkeye tracks the hit/miss patterns of PCs and predicts future reuse, evicting lines unlikely to be reused. This learned policy often outperforms heuristics in workloads with high variance in reuse patterns.",ChampSim_CRC2/champ_repl_pol/hawkeye_final.cc,0.37579227983384317,0.37579227983384317
all,Less is More,"The Less is More (LIME) policy maintains a smaller but more predictable working set in cache by selectively caching only highly reusable data. It introduces filters or confidence thresholds to reduce cache pollution, especially effective in workloads with sparse reuse or high noise. By avoiding over-commitment, it reduces thrashing and improves effective cache utilization in irregular access patterns.",ChampSim_CRC2/champ_repl_pol/lime.cc,0.4332826897688782,0.4332826897688782
all,Multiperspective,"Multiperspective replacement integrates multiple heuristics—temporal (recency), spatial (block adjacency), and frequency (access counts)—to make informed eviction decisions. It balances short-term reuse with longer-term utility predictions, offering adaptability across diverse workloads. This hybrid strategy is especially useful in mixed compute and memory-intensive applications.",ChampSim_CRC2/champ_repl_pol/dancrc2.cc,0.11453256801665043,0.11453256801665043
all,Reordering-based Cache Replacement,"This policy reorders memory accesses to increase temporal locality before they reach the cache. By dynamically reshaping the access stream (e.g., via scheduling queues or address clustering), it reduces conflict misses and enhances reuse. The effectiveness is tied to how well reordering aligns with the underlying data reuse patterns of the workload.",ChampSim_CRC2/champ_repl_pol/red.cc,0.34660260743866517,0.34660260743866517
all,Ship++,"SHiP++ (Signature-based Hit Predictor) is an enhancement over the SHiP policy, which uses PC-based signatures and outcome history to track line usefulness. SHiP++ incorporates refined predictors, decay mechanisms, and hybrid reuse classification to better handle pathological cases (e.g., thrashing). It provides strong performance across workloads with dynamic and complex reuse patterns.",ChampSim_CRC2/champ_repl_pol/ship++.cc,0.37559793796024865,0.37559793796024865
astar,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.2905201544774318,0.2905201544774318
lbm,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.4258286212977946,0.4258286212977946
mcf,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.29648148786739775,0.29648148786739775
milc,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.3042563810067018,0.3042563810067018
omnetpp,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.0053696819496076,0.0053696819496076
all,Adaptive Multi-Policy Tournament (AMPT),"AMPT partitions the LLC sets into sample sets for three base policies—LRU, SRRIP, and PC-Filtered SRRIP—and tracks their miss counts over fixed epochs. At the end of each epoch, the policy with the fewest sample misses “wins” and is applied to all remaining (non-sample) sets in the next epoch. This dynamic tournament lets AMPT adapt to streaming (via LRU), medium‐reuse (via SRRIP), and phase/PC‐driven reuse (via PC-Filtered SRRIP), thereby delivering high hit rates across diverse workloads (astar, LBM, MCF, MILC, omnetpp).",ChampSim_CRC2/new_policies/000_adaptive_multi_policy_tournament__ampt.cc,0.26449126531978673,0.26449126531978673
astar,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.29064083997103546,0.29064083997103546
lbm,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.4397374593189215,0.4397374593189215
mcf,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.28976120003448375,0.28976120003448375
milc,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.3042563810067018,0.3042563810067018
omnetpp,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.007877500442556204,0.007877500442556204
all,SHiP-RRIP (Signature-based Hit Predictor with RRIP),"SHiP-RRIP augments SRRIP with a signature-based hit predictor (SHCT) to distinguish streaming from reusable blocks. Each block carries a PC-derived signature and a “last_hit” flag. On a hit, the block’s signature counter in the SHCT is incremented and the block is promoted (rrpv→0). On an eviction of a block that was never hit, its signature counter is decremented. On insertion, we probe the SHCT: if the counter ≥ threshold, the new block is inserted as “hot” (rrpv=0), otherwise as “cold” (rrpv=2). Eviction still follows standard SRRIP (evict blocks with maximum rrpv, aging others). This approach captures temporal locality even in irregular patterns (mcf, omnetpp), adapts to phase changes (milc), retains spatial reuse (lbm), and avoids pollution from streaming data (astar), yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/001_ship_rrip__signature_based_hit_predictor_with_rrip.cc,0.2664546761547398,0.2664546761547398
astar,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.4549470935094757,0.4549470935094757
lbm,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.4399286899812073,0.4399286899812073
mcf,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.4027614420864229,0.4027614420864229
milc,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.32181184240063143,0.32181184240063143
omnetpp,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.46010462210186637,0.46010462210186637
all,SFSRIP  (Stream-Filter SRRIP with Signature Predictor),"SFSRIP augments Static RRIP (SRRIP) with a small Signature Hit Counter Table (SHCT) that learns which PC+page signatures produce true reuse. On each miss fill, we hash (PC ⊕ paddr>>12) to index SHCT. If the counter is above a tunable threshold, we insert the new line with RRPV=0 (retain it); otherwise we give it RRPV=MAX (effectively bypass). On every hit we reset RRPV to 0 and increment the corresponding SHCT counter, reinforcing good signatures. This filters out streaming or one‐off lines (benefiting lbm, mcf, omnetpp), reacts to irregular and speculatively fetched paths (astar), and smoothly adapts when locality phases change (milc).",ChampSim_CRC2/new_policies/000_sfsrip___stream_filter_srrip_with_signature_predictor.cc,0.41591073801592077,0.41591073801592077
astar,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.3601149555628003,0.3601149555628003
lbm,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.25803618910995835,0.25803618910995835
mcf,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.4134393171901061,0.4134393171901061
milc,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.11828280121943271,0.11828280121943271
omnetpp,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.7241591162593721,0.7241591162593721
all,Tri-Level Signature-based SRRIP (TLSRIP),"TLSRIP is a three-tiered insertion policy built on SRRIP and a Signature Hit Counter Table (SHCT). On every fill we hash (PC⊕paddr>>12) to index SHCT, classifying lines as hot, warm, or cold using two thresholds. Hot lines (SHCT ≥ THRESH_HOT) get RRPV=0 for maximum retention; warm lines (between thresholds) get RRPV=RRPV_MAX–1 for moderate residency; cold lines (SHCT ≤ THRESH_COLD) bypass the cache with RRPV=RRPV_MAX. We also apply eviction feedback: if a line is evicted without any hits, we decrement its SHCT counter. This design retains high‐reuse lines, gives one-shots minimal dwell to avoid pollution, and adaptively responds to phase changes, improving performance across irregular (astar, mcf, omnetpp), streaming (lbm), and mixed-locality (milc) workloads.",ChampSim_CRC2/new_policies/001_tri_level_signature_based_srrip__tlsrip.cc,0.37480647586833393,0.37480647586833393
astar,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.3764590922621157,0.3764590922621157
lbm,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.33827534325646536,0.33827534325646536
mcf,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.43481458857549554,0.43481458857549554
milc,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.20900164377213118,0.20900164377213118
omnetpp,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.29741304749804653,0.29741304749804653
all,Dynamic Signature‐Driven DRRIP (DSD‐RRIP),"DSD‐RRIP combines signature‐based hot‐block identification (à la SHiP) with Dynamic Re‐Reference Interval Prediction (DRRIP). We maintain a small Signature Hit Counter Table (SHCT) to learn which PCs produce high‐reuse blocks and always insert those with low RRPV. For other blocks, we use Set‐Dueling between SRRIP and Bimodal Insertion (BIP): a few “sample” sets try pure SRRIP or pure BIP, and a global PSEL counter tracks which yields more hits. Non‐sample sets follow the winning policy. Hits always reset RRPV and reinforce SHCT; evicted cold blocks decrement SHCT. This hybrid adapts to streaming (lbm), pointer‐chasing (mcf), irregular control (astar, omnetpp), and phase‐changing (milc) workloads.",ChampSim_CRC2/new_policies/002_dynamic_signature_driven_drrip__dsd_rrip.cc,0.33119274307285085,0.33119274307285085
astar,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.045168960580589376,0.045168960580589376
lbm,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.05879291517552144,0.05879291517552144
mcf,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.2143120841923568,0.2143120841923568
milc,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.009520481980057496,0.009520481980057496
omnetpp,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.0011512147403205508,0.0011512147403205508
all,TinyLRU‐Filtered SRRIP (TinySRRIP),"TinySRRIP front‐loads a small fully‐associative LRU “Tiny” filter to admit only lines that show reuse within a short window into the LLC. On an LLC miss, we first probe the TinyLRU filter; if it’s a second (or further) touch within the filter’s history, we insert into LLC with RRPV=0 (hot). Otherwise we insert with RRPV=MAX (so it is the first candidate to be evicted), effectively bypassing one‐time‐use lines. Hits in the LLC reset RRPV to 0, and replacement in the LLC follows standard SRRIP. This simple two‐tier approach filters out streaming and pointer‐chasing pollution (mcf, omnetpp), yet still captures true temporal/spatial reuse (lbm, astar, milc) and naturally adapts to phase changes.",ChampSim_CRC2/new_policies/003_tinylru_filtered_srrip__tinysrrip.cc,0.06578913133376914,0.06578913133376914
astar,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.447423067655105,0.447423067655105
lbm,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.43694939183524384,0.43694939183524384
mcf,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.4122969366239116,0.4122969366239116
milc,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.30125382883045976,0.30125382883045976
omnetpp,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.508848739345426,0.508848739345426
all,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) into an RRIP framework to dynamically distinguish between hot and cold lines using a lightweight PC⊕address signature table. Each fill is tagged with a small saturating counter (SHCT) based on its signature: if the counter is positive, we insert the line with RRPV=0 (long retention), otherwise with RRPV=MAX (quick eviction). On hits, lines are rejuvenated and marked “useful.” Upon eviction, we adjust the SHCT entry up or down depending on whether the line saw a hit during its residency. This approach filters out streaming and pointer‐chasing pollution, adapts swiftly to phase changes, and preserves both spatial and temporal locality, yielding robust hit‐rate improvements across all workloads.",ChampSim_CRC2/new_policies/004_ship_rrip.cc,0.4213543928580292,0.4213543928580292
astar,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.3218924081135098,0.3218924081135098
lbm,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.2588716438586896,0.2588716438586896
mcf,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.4038162607537672,0.4038162607537672
milc,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.16675597587203198,0.16675597587203198
omnetpp,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.26474956605765615,0.26474956605765615
all,DRRIP,"Dynamic Re-Reference Interval Prediction (DRRIP) uses set dueling to adaptively choose between Static RRIP (SRRIP) insertion—favoring moderate retention for temporal locality—and Bimodal Insertion Policy (BIP)—aggressively evicting most new lines to resist pollution from streaming or pointer-chasing patterns. A small fraction of “leader” sets monitor miss behavior under each insertion policy to update a global policy selector (PSEL), while the remaining “follower” sets adopt the current champion policy. By dynamically balancing retention and pollution resistance, DRRIP delivers robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/005_drrip.cc,0.28321717093113097,0.28321717093113097
astar,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.4626695629987668,0.4626695629987668
lbm,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.4392774344950274,0.4392774344950274
mcf,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.4667373721382147,0.4667373721382147
milc,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.3224617479018371,0.3224617479018371
omnetpp,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.45351354897972573,0.45351354897972573
all,SHiP (Signature-based Hit Predictor),"SHiP attaches a small “signature” (derived from the load‐PC) to every new cache line and uses a global Signature History Counter Table (SHCT) to track whether lines brought in by that signature were ever reused before eviction.  On insertion, if the signature’s counter is high (indicating past reuse), we insert the line as MRU; otherwise we give it low priority (long re-reference distance).  On eviction we update the signature’s counter up or down based on whether the line ever hit.  By learning per‐PC reuse behavior, SHiP naturally keeps hot (temporal) data, resists pollution from streaming or pointer-chasing, and adapts to workload phase changes.",ChampSim_CRC2/new_policies/006_ship__signature_based_hit_predictor.cc,0.42893193330271434,0.42893193330271434
astar,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.3341037789337907,0.3341037789337907
lbm,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.10613948928745134,0.10613948928745134
mcf,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.3735984139993975,0.3735984139993975
milc,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.022187303127511823,0.022187303127511823
omnetpp,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.08981264427464523,0.08981264427464523
all,SHiP-DIP (Signature-based Dynamic Insertion Policy),"This hybrid policy retains SHiP’s per‐PC reuse signatures but enhances insertion by mixing SRRIP and a Bimodal Insertion Policy (BIP) for non‐reused streams. On eviction, we update a small Signature History Counter Table (SHCT) as in SHiP. On miss, if a PC’s counter is high (hot), we insert the line as MRU (RRPV=0), capturing temporal locality. Otherwise, we treat it as a likely streaming or pointer‐chasing access and insert with BIP: only 1/32 of such lines are given MRU status, while the rest get the highest RRPV and are evicted quickly. This dynamic insertion adapts to both high‐reuse phases (e.g., stencils, loops) and low‐reuse or streaming phases (e.g., pointer chasing), reducing pollution and improving throughput across all workloads.",ChampSim_CRC2/new_policies/007_ship_dip__signature_based_dynamic_insertion_policy.cc,0.1851683259245593,0.1851683259245593
astar,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.3796705126933054,0.3796705126933054
lbm,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.33606866075568465,0.33606866075568465
mcf,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.43442266375157357,0.43442266375157357
milc,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.25526803623539973,0.25526803623539973
omnetpp,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.36421494652581854,0.36421494652581854
all,DRRIP (Dynamic RRIP with Set Dueling),"DRRIP dynamically steers between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion by sampling a small fraction of sets for each policy and maintaining a global saturating PSEL counter that tracks their relative effectiveness. On each access, SRRIP sample sets always insert with a moderate initial RRPV to favor temporal reuse, while BRRIP sample sets usually insert at the worst RRPV (avoiding pollution from streaming or pointer-chasing blocks) with a rare promotion opportunity. Hits in the respective sample sets increment or decrement PSEL, and the follower sets adopt whichever insertion policy is winning. This adaptive scheme captures high-locality phases (e.g., LBM, ASTAR, MILC) with SRRIP and avoids thrashing in low-reuse, irregular phases (e.g., MCF, OMNETPP) with BRRIP, delivering robust hit-rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/008_drrip__dynamic_rrip_with_set_dueling.cc,0.3539289639923564,0.3539289639923564
astar,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.16566588470424812,0.16566588470424812
lbm,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.09953160041257014,0.09953160041257014
mcf,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.45501874933888703,0.45501874933888703
milc,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.009725048335590201,0.009725048335590201
omnetpp,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.0011512147403205508,0.0011512147403205508
all,SHiP-RRIP,"This policy combines the Signature-based Hit Predictor (SHiP) with an RRIP victim-selection engine to adaptively distinguish high-reuse versus low-reuse lines at insertion time. We maintain a per-PC signature counter table (SHCT) that increments on hits and decrements when a block is evicted without ever being re-referenced. On a miss, the incoming block’s PC signature indexes the SHCT: if the counter is above a threshold, we insert with a moderate RRPV (favoring retention), otherwise with the maximum RRPV (quick eviction). Victim selection uses standard RRIP aging. By steering streaming/pointer-chasing data (e.g., MCF/OMNETPP) to short cache residency and preserving loop-based or spatially reused data (e.g., LBM/ASTAR/MILC), SHiP-RRIP better balances pollution vs. retention across all workloads.",ChampSim_CRC2/new_policies/009_ship_rrip.cc,0.1462184995063232,0.1462184995063232
astar,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.42954542233057874,0.42954542233057874
lbm,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.40828546825764817,0.40828546825764817
mcf,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.5027922550997534,0.5027922550997534
milc,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.30764969550388493,0.30764969550388493
omnetpp,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.5800084699763198,0.5800084699763198
all,Dueling SHiP-RRIP,"We combine the PC‐based SHiP predictor with standard SRRIP in a dynamic, set‐dueling framework. A small number of “leader” sets are hardwired to use SHiP insertion or SRRIP insertion; misses in those leaders update a global saturating counter (PSEL) that chooses the better policy for all other “follower” sets. This lets the policy automatically favor SHiP’s PC‐based retention when reuse dominates (e.g., loops, stencils, phase‐changes) and fall back to pure SRRIP’s low‐pollution behavior when streaming/pointer‐chasing workloads prevail, yielding robust hit‐rate improvements across all five benchmarks.",ChampSim_CRC2/new_policies/010_dueling_ship_rrip.cc,0.44565626223363697,0.44565626223363697
astar,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.4225113041999178,0.4225113041999178
lbm,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.408412614000458,0.408412614000458
mcf,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.5114436225061645,0.5114436225061645
milc,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.3051116244378951,0.3051116244378951
omnetpp,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.5314373311223911,0.5314373311223911
all,Dueling AIP-RRIP,"We extend the SHiP predictor to assign graded insertion priorities based on the SHCT counter (Adaptive Insertion Priority, AIP), mapping predicted reuse confidence into four distinct RRPV levels (from immediate promotion to longest re-reference prediction). We then duel this AIP-RRIP insertion policy against pure SRRIP using a small set-dueling machinery. This fine-grained insertion control retains truly hot data longer, quickly evicts useless streams, and dynamically picks the best policy per phase, improving performance across branch-heavy, streaming, pointer-chasing, and mixed‐locality workloads.",ChampSim_CRC2/new_policies/011_dueling_aip_rrip.cc,0.4357832992533653,0.4357832992533653
astar,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.04537626330635445,0.04537626330635445
lbm,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.0587531723306529,0.0587531723306529
mcf,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.21521451608835637,0.21521451608835637
milc,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.009520481980057496,0.009520481980057496
omnetpp,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.0011512147403205508,0.0011512147403205508
all,Set-Locality Aware RRIP (SLA-RRIP),"SLA-RRIP uses a lightweight per-set saturating counter to classify each cache set’s behavior as streaming, moderate-reuse, or heavy-reuse. On every hit the counter increments (signifying temporal locality) and on every miss it decrements (signifying a streaming or cold access pattern). When filling a new block, streaming sets insert with the maximum RRPV to approximate bypass and avoid polluting the cache, heavy‐reuse sets insert at RRPV=0 to retain hot data longest, and moderate‐reuse sets insert at the standard SRRIP position. Victim selection uses standard RRIP aging. This per-set dynamic adaptation reacts quickly to phase changes and diverse access patterns—by bypassing cold streams, prioritizing hot data, and using conservative insertion when uncertain—improving performance across branch‐heavy, streaming, pointer‐chasing, and mixed‐locality workloads with very low overhead.",ChampSim_CRC2/new_policies/012_set_locality_aware_rrip__sla_rrip.cc,0.06600312968914836,0.06600312968914836
astar,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.46249503890912697,0.46249503890912697
lbm,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.44019280920821047,0.44019280920821047
mcf,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.5181277643824945,0.5181277643824945
milc,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.17138134789314757,0.17138134789314757
omnetpp,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.5071607088535112,0.5071607088535112
all,SHiP-RRIP,"This policy integrates the Signature-based Hit Predictor (SHiP) with RRIP to dynamically adapt insertion priorities based on per-PC reuse histories. Each incoming block carries a PC‐derived signature used to index a small saturating counter (the SHCT). On eviction, we update that counter depending on whether the block was re-referenced, strengthening or weakening its reuse prediction. Blocks from PCs with strong reuse history are inserted as MRU (RRPV=0), streaming PCs are bypassed (RRPV=RRPV_MAX), and others use standard SRRIP insertion. This low-overhead approach captures both fine‐grain temporal locality and streaming behavior, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/013_ship_rrip.cc,0.4198715338492981,0.4198715338492981
astar,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.42325281010361593,0.42325281010361593
lbm,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.42976317094311484,0.42976317094311484
mcf,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.5138393276199523,0.5138393276199523
milc,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.14277102326625488,0.14277102326625488
omnetpp,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.045267195151775436,0.045267195151775436
all,SHiP-DIP,"SHiP-DIP synergistically combines per-PC signature‐based reuse prediction (from SHiP) with a Dynamic Insertion Policy (DIP) that duels between SRRIP and BRRIP. A small per‐PC saturating counter (SHCT) classifies incoming blocks as heavy-reuse, streaming, or uncertain; heavy-reuse blocks are immediately promoted to MRU, streaming blocks are bypassed, and uncertain blocks use the current global insertion policy determined by set dueling. Two groups of leader sets independently test pure SRRIP and BRRIP and update a global PSEL counter to steer future insertions. This fusion captures fine-grain PC-level reuse signals for irregular, pointer-chasing and phase-changing workloads, while dynamically adapting to coarse-grain regular vs. streaming behavior, leading to higher hit rates across all targeted applications.",ChampSim_CRC2/new_policies/014_ship_dip.cc,0.31097870541694267,0.31097870541694267
astar,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.40918900338771635,0.40918900338771635
lbm,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.41565259520285847,0.41565259520285847
mcf,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.500874941507113,0.500874941507113
milc,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.13949434093427085,0.13949434093427085
omnetpp,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.04472439441929269,0.04472439441929269
all,Adaptive SHiP-DIP,"Adaptive SHiP-DIP builds on SHiP-DIP by introducing a dynamically tuned reuse‐prediction threshold and an implicit low‐priority bypass for streaming data. We monitor the application miss rate in lightweight epochs and adjust the SHCT threshold to expand or contract the set of blocks treated as heavy‐reuse versus streaming. This lets the policy self-adapt to phases of high spatial locality (e.g., LBM), pointer chasing (MCF/Omnet++), or irregular reuse (ASTAR/MILC), while preserving the proven SRRIP/BRRIP dueling for uncertain blocks.",ChampSim_CRC2/new_policies/015_adaptive_ship_dip.cc,0.30198705509025026,0.30198705509025026
astar,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.3791247926972742,0.3791247926972742
lbm,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.33284443325756957,0.33284443325756957
mcf,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.47324517098908736,0.47324517098908736
milc,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.23883393556702898,0.23883393556702898
omnetpp,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.4473400099015216,0.4473400099015216
all,Adaptive Epoch Insertion (AEI),"Adaptive Epoch Insertion (AEI) dynamically selects between three insertion priorities—MRU, bypass, and SRRIP—based on recent cache behavior measured over fixed‐length epochs. AEI tracks the hit rate and the “thrash rate” (the fraction of evicted blocks that never saw a hit) during each epoch. If thrash rate is high, AEI assumes streaming or pointer‐chasing behavior and bypasses new blocks to reduce pollution; if hit rate is high, it promotes new blocks to MRU to capture heavy spatial reuse; otherwise it uses SRRIP’s middle priority to balance recency and reuse. This simple epoch‐based adaptation tailors insertion to streaming (LBM, MCF, Omnet++), heavy‐reuse (LBM, MILC), and mixed/branch‐heavy phases (ASTAR, MILC) without complex per‐PC tuning, yielding robust performance across diverse workloads.",ChampSim_CRC2/new_policies/016_adaptive_epoch_insertion__aei.cc,0.3742776684824964,0.3742776684824964
astar,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.466233575245574,0.466233575245574
lbm,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.4405599566993062,0.4405599566993062
mcf,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.5296160266644063,0.5296160266644063
milc,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.2640028385844732,0.2640028385844732
omnetpp,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.5312404936445354,0.5312404936445354
all,SHiP-RRIP,"This policy combines the SRRIP framework with a Signature-based Hit Predictor (SHiP) to make fine‐grained insertion decisions per‐PC. A small global Signature History Counter Table (SHCT) tracks how often blocks from each PC‐signature are actually reused by incrementing on hits and decrementing on evictions of never‐hit blocks. On insertion, blocks whose signature counter is strong are given MRU priority, streaming PCs with zero counter are bypassed (inserted with maximum RRPV), and ambiguous PCs get SRRIP’s default medium priority. Evictions use standard RRIP victim selection. This per‐PC adaptation quickly learns and distinguishes high‐reuse stencil phases (LBM, MILC), pointer‐chasing streams (MCF, omnetpp) and mixed phases (astar), yielding a higher overall hit rate than a coarse epoch‐based scheme.",ChampSim_CRC2/new_policies/017_ship_rrip.cc,0.44633057816765903,0.44633057816765903
astar,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.4634881429928135,0.4634881429928135
lbm,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.4369641823019769,0.4369641823019769
mcf,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.5278862204936768,0.5278862204936768
milc,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.2658095396713904,0.2658095396713904
omnetpp,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.5309005016373299,0.5309005016373299
all,DIP-SHiP-RRIP,"DIP-SHiP-RRIP dynamically chooses between SHiP-RRIP and plain SRRIP on a per-set basis using set-dueling. Two small cohorts of “sample” sets independently run SRRIP and SHiP-RRIP and update a global saturating counter (PSEL). The remaining sets consult PSEL to pick whichever policy has most hits recently. This hybrid captures SHiP’s fine-grained per-PC reuse learning on pointer-chasing and phase-sensitive workloads (mcf, omnetpp, astar phases) while falling back to cheaper SRRIP on streaming/stencil workloads (lbm, milc). By automatically adapting to phase changes and the dominant access pattern, it boosts overall hit rate with minimal overhead.",ChampSim_CRC2/new_policies/018_dip_ship_rrip.cc,0.44500971741943757,0.44500971741943757
astar,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.45731867212859145,0.45731867212859145
lbm,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.4401190012074232,0.4401190012074232
mcf,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.5283243958907612,0.5283243958907612
milc,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.27425650086533376,0.27425650086533376
omnetpp,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.5439693172125427,0.5439693172125427
all,SHiP++,"SHiP++ augments the original SHiP insertion policy with two lightweight enhancements: sequential‐stream detection and bypass filtering. Pointer‐chasing and phase‐sensitive blocks are still tracked via a per‐PC saturating counter table (SHCT) to promote frequently reused lines (RRPV→0) and demote one‐time blocks (bypass on refill). Additionally, when two consecutive misses map to adjacent cache blocks, those lines are given a middle‐ground insertion age to exploit spatial locality without long‐term retention. This combined approach reduces pollution from streaming workloads (e.g., LBM), preserves hot pointer‐chasing data (e.g., MCF, Omnet++), and dynamically adapts to phase changes (e.g., MILC, A*), yielding higher overall hit rate.",ChampSim_CRC2/new_policies/019_ship.cc,0.4487975774609304,0.4487975774609304
astar,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.13139980722618322,0.13139980722618322
lbm,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.07591829628101598,0.07591829628101598
mcf,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.3013606314260115,0.3013606314260115
milc,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.13267847961939797,0.13267847961939797
omnetpp,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.5382491008106125,0.5382491008106125
all,RDAR: Reuse Distance-Aware Replacement,"RDAR extends SHiP++ by incorporating per-PC reuse-distance estimation and enhanced sequential-stream handling to better match insertion priority to actual reuse behavior. A small Reuse Distance Counter Table (RDCT) indexed by PC signatures is updated on every cache hit: we measure the reuse interval via a global reference counter and per-line timestamps, and classify it as “short” or “long” to increment or decrement the corresponding saturating counter. On a miss, blocks predicted to be reused soon (high RDCT counter) are inserted as MRU (RRPV=0), unlikely-to-be-reused blocks (zero RDCT counter) are bypassed (RRPV=MAX), and detected sequential streams receive moderate insertion priority (SRRIP_INIT–1). This adaptive policy reduces pollution from one-time data, retains hot pointer-chasing lines, and exploits spatial locality in streams, yielding higher hit rates across control-dominated, streaming, and mixed-phase workloads.",ChampSim_CRC2/new_policies/020_rdar__reuse_distance_aware_replacement.cc,0.23592126307264422,0.23592126307264422
astar,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.33873974117280187,0.33873974117280187
lbm,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.36282241260865367,0.36282241260865367
mcf,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.525456997250486,0.525456997250486
milc,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.2722542850315358,0.2722542850315358
omnetpp,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.07251373388765948,0.07251373388765948
all,SHiP-DIP,"SHiP-DIP combines SHiP’s PC-based reuse‐frequency tracking with DRRIP’s dynamic insertion policy selection (DIP) and simple sequential‐stream handling. Each block carries a small saturating counter indexed by its PC signature (PCT) to predict “hot” or “cold” PCs. On a miss, blocks from hot PCs are inserted at MRU, blocks from cold PCs are bypassed, and the rest follow a global policy selector (PSEL) that dynamically toggles between SRRIP (favoring temporal locality) and BRRIP (defensive, streaming‐friendly) based on miss outcomes in two small sample‐set groups. Consecutive sequential misses get a moderate priority. This hybrid design quickly adapts to streaming workloads (lbm), pointer­chasing (mcf), control‐dominated behavior (astar, omnetpp), and phase changes (milc), reducing cache pollution and boosting hit rates across all benchmarks.",ChampSim_CRC2/new_policies/021_ship_dip.cc,0.3143574339902274,0.3143574339902274
astar,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.35643577513501257,0.35643577513501257
lbm,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.4402476920805908,0.4402476920805908
mcf,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.5283571613206932,0.5283571613206932
milc,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.2718777381116172,0.2718777381116172
omnetpp,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.07349195650488216,0.07349195650488216
all,SHiP-TriDIP,"SHiP-TriDIP extends SHiP’s PC-based hot/cold classification with simple sequential-stream detection and a three-way set-dueling (DIP) among SRRIP, BRRIP, and LRU insertion policies. Two global saturating counters (PSEL0 for SRRIP vs. BRRIP, PSEL1 for SRRIP vs. LRU) are trained on dedicated sample sets. On a miss, hot PCs are strongly promoted (MRU), cold PCs bypass, sequential streams receive moderate priority, and ambiguous PCs invoke the tri-DIP logic: if LRU wins, insert MRU; else if BRRIP wins, insert rarely MRU; otherwise use SRRIP. This hybrid adapts rapidly to high temporal-locality phases (milc, astar), streaming stencil accesses (lbm), pointer-chasing (mcf, omnetpp), and phase changes, reducing pollution and boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/022_ship_tridip.cc,0.33408206463055923,0.33408206463055923
astar,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.4548620462373669,0.4548620462373669
lbm,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.4209470494834396,0.4209470494834396
mcf,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.4023653675335338,0.4023653675335338
milc,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.3098655293018675,0.3098655293018675
omnetpp,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.50556214994244,0.50556214994244
all,DRIP (Dynamic Reuse Interval‐based Insertion Policy),"DRIP dynamically tunes insertion priority by estimating per‐PC reuse intervals and detecting small‐stride streaming. Each PC signature records its last access timestamp and observed block stride to classify misses as hot (short reuse interval → MRU promotion), streaming (constant small strides → moderate retention), or cold (long reuse interval → bypass). This unified scheme adapts instantly to temporal phases (astar, milc), spatial streams (lbm), pointer‐chasing (mcf, omnetpp), and phase changes, minimizing pollution and raising hit rates across all workloads.",ChampSim_CRC2/new_policies/023_drip__dynamic_reuse_interval_based_insertion_policy.cc,0.41872042849972957,0.41872042849972957
astar,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.4568686303136827,0.4568686303136827
lbm,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.43999008319517935,0.43999008319517935
mcf,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.507155136300653,0.507155136300653
milc,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.2620205362897094,0.2620205362897094
omnetpp,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.5319264424310025,0.5319264424310025
all,SHiPPlus,"SHiPPlus combines the signature-based hit predictor (SHiP) with lightweight small-stride streaming detection on top of SRRIP. Each PC signature maintains a small saturating counter that is incremented on cache hits and decremented on block evictions without hits, predicting whether future blocks from that PC will be reused. In addition, we detect constant small-stride streams per signature and give them moderate retention. On a miss, hot signatures are inserted at MRU, streaming flows at near-MRU, potential reuse at SRRIP’s default insertion, and cold signatures are bypassed. This unified scheme captures temporal reuse, spatial streaming, and cold flows, adapts to phase changes, and minimizes pollution for improved hit rates across all workloads.",ChampSim_CRC2/new_policies/024_shipplus.cc,0.4395921657060454,0.4395921657060454
astar,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.46422699116925825,0.46422699116925825
lbm,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.4399846327957335,0.4399846327957335
mcf,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.5257710437663264,0.5257710437663264
milc,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.2785523943315206,0.2785523943315206
omnetpp,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.5642614717478571,0.5642614717478571
all,ThrashAware SHiP-RRIP (TASR),"TASR extends SHiPPlus by adding per‐signature miss counters to identify pointer‐chasing “thrashers” and bypass their blocks, while retaining signature‐based hot/cold prediction and small‐stride stream detection. We also periodically decay SHiP counters to track phase changes. By bypassing streams and low‐reuse pointer flows, promoting true reuse, and adapting to workload phases, TASR reduces pollution and boosts hit rates on both regular stencil codes and irregular, pointer‐heavy kernels.",ChampSim_CRC2/new_policies/025_thrashaware_ship_rrip__tasr.cc,0.4545593067621391,0.4545593067621391
astar,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.1703930955789593,0.1703930955789593
lbm,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.14046310052139024,0.14046310052139024
mcf,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.4203426685216553,0.4203426685216553
milc,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.06011897434412044,0.06011897434412044
omnetpp,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.5349386523194016,0.5349386523194016
all,Dynamic DBP-DIP SHiP (DDSH),"DDSH extends TASR by layering two adaptive mechanisms: (1) a Bloom‐filter Dead‐Block Predictor (DBP) that rapidly identifies and bypasses thrashing flows at insertion time, and (2) a Set‐Dueling Insertion Policy (DIP) that dynamically chooses between signature‐guided SHiP insertion and baseline SRRIP insertion per workload phase. DBP prevents pollution from pointer‐chasing kernels, while DIP steers the cache toward the best insertion strategy (signature vs. SRRIP) for current workloads. Combined with SHiP’s hot/cold prediction, small‐stride stream detection, and periodic counter decay, DDSH improves hit rates across both regular stencil codes and highly irregular, memory‐bound kernels.",ChampSim_CRC2/new_policies/026_dynamic_dbp_dip_ship__ddsh.cc,0.26525129825710536,0.26525129825710536
astar,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.19472813222015903,0.19472813222015903
lbm,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.12271454985550637,0.12271454985550637
mcf,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.42232865523130614,0.42232865523130614
milc,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.0460998428640738,0.0460998428640738
omnetpp,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.5349028636870642,0.5349028636870642
all,Per-PC Adaptive Reuse Policy (PARP),"PARP combines per-PC dynamic policy selection with signature-based hot/cold prediction, small-stride stream demotion, and a Bloom-filter dead-block bypass. For each access, a lightweight per-PC counter chooses between SHiP-guided insertion (promote heavy reuse) or baseline SRRIP insertion, allowing fine-grained adaptation to different code regions and runtime phases. A small-stride detector demotes streaming patterns, and a dead-block predictor bypasses thrashing flows (e.g., pointer-chasing in MCF/Omnet++). This hybrid approach promotes blocks with demonstrated temporal reuse (ASTAR/MILC), demotes regular streams (LBM), and filters out polluters, yielding higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/027_per_pc_adaptive_reuse_policy__parp.cc,0.2641548087716219,0.2641548087716219
astar,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.049734936001927736,0.049734936001927736
lbm,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.06537154969293806,0.06537154969293806
mcf,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.21820001919448992,0.21820001919448992
milc,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.015742557767366418,0.015742557767366418
omnetpp,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.009746553811833055,0.009746553811833055
all,PDIP (PC-based Dynamic Insertion Policy),"PDIP classifies each static PC into hot, neutral, or cold based on its observed hit/miss ratio, and augments this with stride‐based stream detection and a Bloom‐filter dead‐block predictor. Cold PCs bypass or are demoted in the cache to eliminate thrash (benefiting MCF/Omnetpp), hot PCs insert at MRU to capture reuse (helping ASTAR/MILC), and neutral PCs follow SRRIP insertion with a bimodal twist on detected streams (optimizing LBM). This per‐PC, pattern‐aware insertion strategy dynamically adapts to phase changes and irregular behaviors, driving up overall hit rates across diverse workloads.",ChampSim_CRC2/new_policies/028_pdip__pc_based_dynamic_insertion_policy.cc,0.07175912329371104,0.07175912329371104
astar,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.3670463082396632,0.3670463082396632
lbm,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.4132680290235769,0.4132680290235769
mcf,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.4307489586704607,0.4307489586704607
milc,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.18053795520539911,0.18053795520539911
omnetpp,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.5620425765429374,0.5620425765429374
all,SHiP-S (Signature-based Hit Predictor with Stream Awareness),"This hybrid policy combines the proven SHiP (Signature-based Hit Predictor) mechanism with lightweight per‐PC stream detection to handle both irregular pointer‐chasing and regular stencil/streaming patterns. We maintain a small saturating SHCT indexed by PC signatures: hot signatures insert at MRU, cold signatures insert at long re‐reference (to evict quickly), and middle counters insert at default SRRIP RRPV. In parallel, we track simple constant‐stride streams per PC; when a stream is detected, even if initially predicted cold, we give it a default mid‐level RRPV so it survives just long enough to capture neighbor reuse (critical for LBM and MILC). On eviction, we update the SHCT based on whether the block saw a hit. This lets us filter out thrashing accesses (e.g., MCF/OMNETPP), retain genuinely reusable data (e.g., ASTAR/MILC), and capture streaming locality (e.g., LBM), yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/029_ship_s__signature_based_hit_predictor_with_stream_awareness.cc,0.3907287655364075,0.3907287655364075
astar,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.4284539823385165,0.4284539823385165
lbm,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.413526193373543,0.413526193373543
mcf,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.4608581559985597,0.4608581559985597
milc,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.3100556130835572,0.3100556130835572
omnetpp,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.4497139891799035,0.4497139891799035
all,DRRIP-Stream,"This policy implements Dynamic Re‐reference Interval Prediction (DRRIP) with set dueling between SRRIP and BRRIP insertion policies, augmented by lightweight per‐PC stride detection to identify streaming accesses. Two small sample sets track miss rates under pure SRRIP and BRRIP to update a global PSEL counter, which steers the insertion policy for all other sets—favoring aggressive eviction for thrashing workloads (e.g., MCF/OMNETPP) or moderate retention for high‐locality workloads (e.g., ASTAR/MILC). When a constant‐stride stream is detected, we always use SRRIP insertion (mid‐RRPV) to preserve spatial reuse, boosting performance on stencil/streaming codes like LBM. This adaptive hybrid yields robust hit‐rate improvements across diverse, phase‐changing behaviors.",ChampSim_CRC2/new_policies/030_drrip_stream.cc,0.41252158679481604,0.41252158679481604
astar,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.09762629519908149,0.09762629519908149
lbm,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.20182552134096143,0.20182552134096143
mcf,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.21449842486092752,0.21449842486092752
milc,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.17281693302533727,0.17281693302533727
omnetpp,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.11056433381648563,0.11056433381648563
all,SHiP-Stream,"This policy integrates the Signature-based Hit Predictor (SHiP) with Re‐Reference Interval Prediction (RRIP) and lightweight per‐PC stride‐based stream detection to adaptively guide cache insertions and evictions. A per‐PC saturating counter learns whether blocks are likely to be reused: on misses, blocks with high counter values (or identified as streaming) are inserted with medium re‐reference priority, while low‐prediction blocks are inserted as eviction candidates to minimize pollution. On block eviction, counters are updated based on whether the block was reused, accelerating reuse learning. This hybrid approach quickly adapts to phase changes, filters pointer‐chasing noise (MCF, OMNETPP), preserves spatial locality for stencils (LBM), and boosts instruction‐level reuse (ASTAR, MILC), achieving higher hit rates across diverse workloads.",ChampSim_CRC2/new_policies/031_ship_stream.cc,0.15946630164855868,0.15946630164855868
astar,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.36930449049596736,0.36930449049596736
lbm,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.14695902149701268,0.14695902149701268
mcf,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.4244171954488075,0.4244171954488075
milc,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.040362933300506165,0.040362933300506165
omnetpp,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.10606087718984307,0.10606087718984307
all,DIP-SHiP-Stream,"DIP-SHiP-Stream combines the strengths of Signature-based Hit Prediction (SHiP) with Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) controller. Two small sample sets drive a global choice between SHiP-Stream insertion—which retains blocks predicted reusable by PC signatures or detected as regular streams—and aggressive Bimodal insertion—which rapidly evicts likely dead blocks. Follower sets adopt whichever insertion policy yields higher hit rates in the samples. This hybrid adapts on the fly: SHiP-Stream handles regular stencils and phase-changing loops (LBM, MILC), while Bimodal insertion curtails pollution from pointer-chasing and unpredictable workloads (MCF, OMNETPP), delivering robust performance across diverse benchmarks.",ChampSim_CRC2/new_policies/032_dip_ship_stream.cc,0.21742090358642735,0.21742090358642735
astar,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.25071935817658647,0.25071935817658647
lbm,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.07764675156559606,0.07764675156559606
mcf,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.44683431067685037,0.44683431067685037
milc,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.009520481980057496,0.009520481980057496
omnetpp,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.0011512147403205508,0.0011512147403205508
all,Predictive Insertion with Bimodal PC Table (PIBT),"PIBT uses a tiny per‐PC hit/total counter table to classify instruction PCs into high‐reuse (temporal locality) or low‐reuse streams. On a miss, if a PC’s past hit rate exceeds 50% (and it has at least 8 samples), the new block is given “long‐lived” priority (RRPV=0); otherwise it is given “short‐lived” priority (RRPV=RRPV_MAX). Hits always reset RRPV to 0 and update the PC’s counters. Replacement uses standard SRRIP. This simple predictor adapts quickly to both regular stencil codes (LBM, MILC), dynamic phases (ASTAR), and pointer‐chasing/branch‐heavy irregulars (MCF, OMNETPP), yielding robust overall hit rates with minimal metadata.",ChampSim_CRC2/new_policies/033_predictive_insertion_with_bimodal_pc_table__pibt.cc,0.15717442342788218,0.15717442342788218
astar,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.46616713206423904,0.46616713206423904
lbm,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.44075299300905757,0.44075299300905757
mcf,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.5094535901926445,0.5094535901926445
milc,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.2605342621490691,0.2605342621490691
omnetpp,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.5339485001580665,0.5339485001580665
all,SHiP-RRIP,"We integrate a lightweight signature-based hit predictor (SHiP) with SRRIP. Each block’s insertion PC is hashed to index a global table of 3-bit saturating counters (“signatures”), which track whether past blocks from that PC were actually reused before eviction. On a miss, if the counter for this signature ≥ threshold (4/7), we insert near MRU (RRPV=0); otherwise we insert far (RRPV=RRPV_MAX). On a hit we reset RRPV=0 and mark the block as “referenced.” Upon eviction we use that mark to increment or decrement the corresponding signature counter. This approach captures both spatial/stencil locality (LBM, MILC) and pointer-heavy irregulars (MCF, omnetpp), and quickly adapts to dynamic phases (astar), yielding much higher hit rates than simple bimodal PC tables.",ChampSim_CRC2/new_policies/034_ship_rrip.cc,0.44217129551461537,0.44217129551461537
astar,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.4341742972969142,0.4341742972969142
lbm,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.3906638556542606,0.3906638556542606
mcf,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.5082917862524404,0.5082917862524404
milc,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.12844956805723512,0.12844956805723512
omnetpp,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.5393167950086788,0.5393167950086788
all,Multi-Level SHiP-RRIP,"We extend SHiP-RRIP’s binary insertion policy into four distinct priority levels by upgrading the signature counters to 4 bits and defining three thresholds. On a miss, we classify each PC signature into one of four reuse‐likelihood bands—“streaming,” “low,” “medium,” or “high”—and map them to insertion RRPVs of 3, 2, 1, or 0, respectively. This finer granularity captures the wide spectrum of access patterns across astar, lbm, mcf, milc, and omnetpp, avoiding pollution from pure streams, giving moderate reuse blocks a fair chance, and aggressively retaining highly reusable data. We initialize all signatures to the medium band to adapt quickly in new phases while still converging rapidly to all workloads’ reuse characteristics.",ChampSim_CRC2/new_policies/035_multi_level_ship_rrip.cc,0.4001792604539059,0.4001792604539059
astar,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.4296437582389545,0.4296437582389545
lbm,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.3649490818456577,0.3649490818456577
mcf,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.4556685272673268,0.4556685272673268
milc,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.1800220135122414,0.1800220135122414
omnetpp,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.5405992210007694,0.5405992210007694
all,DIP-SHiP-BIP,"We combine PC-based signed reuse prediction (SHiP) with a Bimodal Insertion Policy (BRRIP) under a Dynamic Insertion Policy (DIP) framework. We carve out a small number of “leader” sets to sample pure SHiP vs pure BIP; on misses in those sets we update a global PSEL saturating counter to track which policy is currently winning. All other “follower” sets then choose between SHiP or BIP based on PSEL. This hybrid adapts to heavy temporal‐reuse phases (mcf, milc) by favoring SHiP, to streaming or poor‐reuse phases (lbm, astar, omnetpp) by favoring BIP, and tracks phase shifts online—yielding higher hit rates across all workloads.",ChampSim_CRC2/new_policies/036_dip_ship_bip.cc,0.39417652037299,0.39417652037299
astar,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.04512466512636607,0.04512466512636607
lbm,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.0587531723306529,0.0587531723306529
mcf,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.2143120841923568,0.2143120841923568
milc,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.009520481980057496,0.009520481980057496
omnetpp,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.0011512147403205508,0.0011512147403205508
all,PC-SHiP,"We replace the global DIP arbitration with a fine‐grained, per‐PC saturation counter that drives a 4‐tier RRIP insertion. Each load/store PC hashes to a small counter that is incremented when its blocks are actually reused and decremented when evicted without reuse. On a miss we consult that PC’s counter and insert at one of four RRPV values (long, medium, short, MRU). Unknown or one‐shot accesses naturally get far insertion (avoiding pollution), while heavily‐reused PCs quickly earn MRU insertion. This per‐PC adaptation handles streaming, pointer‐chasing, and heavy‐reuse phases in a unified mechanism, improving hit rates across all workloads without global policy flipping.",ChampSim_CRC2/new_policies/037_pc_ship.cc,0.06577232367395076,0.06577232367395076
astar,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.32290677401522344,0.32290677401522344
lbm,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.25941577796913295,0.25941577796913295
mcf,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.40440484196368526,0.40440484196368526
milc,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.1668446816368205,0.1668446816368205
omnetpp,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.2646004449773038,0.2646004449773038
all,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP) using set dueling between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP). A small number of “sample” sets are dedicated to each policy to track which insertion strategy yields more hits, updating a global PSEL counter. All other sets (“followers”) use whichever policy is currently winning. SRRIP inserts at a medium re-reference interval to favor recency, while BRRIP mostly inserts at a far interval (with a rare MRU insertion) to bypass streaming and pointer-chasing blocks. This adaptive combination balances temporal locality and pollution avoidance, and has been shown to perform robustly across both regular and irregular workloads.",ChampSim_CRC2/new_policies/038_drrip.cc,0.2836345041124332,0.2836345041124332
astar,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.4736716679187515,0.4736716679187515
lbm,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.44075299300905757,0.44075299300905757
mcf,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.5291500207701559,0.5291500207701559
milc,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.3227188135875508,0.3227188135875508
omnetpp,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.5367101896201036,0.5367101896201036
all,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with RRIP to learn per‐instruction reuse behavior and adapt insertion priorities dynamically. A small global Signature History Counter Table (SHCT) tracks, via saturating counters, whether blocks loaded by a given PC‐derived signature tend to be reused. On insertion, if the signature’s counter exceeds a threshold, we treat it as high‐reuse—insert as MRU (RRPV=0); otherwise as long‐reuse—insert as distant (RRPV=MAX). On a hit, we promote the block and increment its signature counter; on victim selection, if the block was never reused we decay the counter. This approach avoids polluting the cache with non‐reusable streams (pointer chasing, streaming) while preserving high‐reuse data, and it naturally adapts to phase changes, improving hit rates across diverse workloads.",ChampSim_CRC2/new_policies/039_ship_rrip.cc,0.4606007369811239,0.4606007369811239
astar,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.435787537739727,0.435787537739727
lbm,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.44057509680203183,0.44057509680203183
mcf,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.5296854192483602,0.5296854192483602
milc,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.32516636856702175,0.32516636856702175
omnetpp,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.5378613906269571,0.5378613906269571
all,Adaptive-SHiP-RRIP,"Adaptive-SHiP-RRIP enhances the original SHiP-RRIP by introducing a dynamic insertion threshold and a three-tier insertion priority to better capture varying reuse patterns and workload phases. We monitor the miss rate over a sliding window of accesses and adjust the SHCT threshold upward when the miss rate falls (favoring stronger filtering of one-shot blocks) and downward when the miss rate rises (allowing more blocks to be inserted at or near MRU to exploit bursts of locality). Furthermore, instead of a binary MRU/distant insertion, we map per‐signature reuse counters into three RRPV insertion values—MRU for high reuse, one step away from MRU for moderate reuse, and distant for low reuse—enabling finer‐grained retention decisions. This adaptive scheme quickly reacts to phase changes in diverse workloads (e.g., lbm vs. mcf vs. milc vs. omnetpp vs. astar), improving overall hit rates.",ChampSim_CRC2/new_policies/040_adaptive_ship_rrip.cc,0.45381516259681953,0.45381516259681953
astar,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.3503788147245177,0.3503788147245177
lbm,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.2471106114886667,0.2471106114886667
mcf,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.30636156023201727,0.30636156023201727
milc,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.010619347270396895,0.010619347270396895
omnetpp,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.0023024294806411015,0.0023024294806411015
all,ARD-RRIP,"ARD-RRIP augments standard RRIP with per-PC reuse-interval prediction to guide insertion priority. We maintain, for each PC signature, running sums and counts of observed reuse intervals (measured in number of accesses between references). On a hit, we compute the interval since the last reference, update the signature’s statistics, and promote the block to MRU. On a miss, we predict the signature’s average reuse interval: if the signature is well-sampled and predicts a short interval, we allocate at MRU; if moderate, we allocate near MRU; otherwise (long interval or no samples), we allocate at RRPV_MAX to quickly evict one-shot blocks. When evicting a block that was never reused, we decay the signature’s confidence counter to adapt to phase changes. This lets us retain hot, repetitively used data in stencil or phase-stable codes (lbm, milc), bypass pointer-chasing and streaming patterns (mcf, astar, omnetpp), and automatically adjust to phase shifts.",ChampSim_CRC2/new_policies/041_ard_rrip.cc,0.18335455263924796,0.18335455263924796
astar,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.25554224723242003,0.25554224723242003
lbm,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.1662373792333387,0.1662373792333387
mcf,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.39469230381250736,0.39469230381250736
milc,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.05580497766062985,0.05580497766062985
omnetpp,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.4218823627655069,0.4218823627655069
all,Duel-SHiP-RRIP,"Duel-SHiP-RRIP dynamically adapts between a Signature-based Hit Predictor (SHiP) insertion policy and a Bimodal RRIP (BRRIP) insertion policy via lightweight set dueling. We partition the LLC sets into SHiP-sample, BRRIP-sample, and follower sets. A small PSEL counter monitors miss outcomes in the two sample groups to choose the winner for all follower sets. SHiP uses per-PC saturating counters to detect recurrently reused lines (ideal for pointer-chasing and phase-bearing codes), inserting predicted-hot lines closer to MRU, while BRRIP streams or streaming-like patterns by mostly inserting at far RRPV with rare retention. This design captures the strengths of both policies—preserving temporal locality in irregular workloads and avoiding pollution from one-shot data in streaming and stencil codes—yielding robust performance across astar, lbm, mcf, milc, and omnetpp.",ChampSim_CRC2/new_policies/042_duel_ship_rrip.cc,0.2588318541408806,0.2588318541408806
astar,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.25258153907213426,0.25258153907213426
lbm,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.17485782416563367,0.17485782416563367
mcf,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.45174340204199576,0.45174340204199576
milc,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.23492364062941265,0.23492364062941265
omnetpp,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.6473746055794478,0.6473746055794478
all,Adaptive Reuse–Phase Replacement (ARPR),"ARPR augments a lightweight per‐PC reuse predictor with an epoch‐based adaptive threshold to dynamically tune insertion priority according to temporal locality and phase behavior. On each miss, the PC’s predictor counter decides whether to insert near‐MRU (hot reuse) or far (likely one‐time/streaming). Periodically, ARPR measures hit rates over a reference epoch and adjusts its reuse threshold up or down to shift between aggressive reuse retention (benefitting pointer‐chasing, phase‐bearing workloads) and conservative insertion (benefitting stencil, streaming codes). This continuous feedback loop quickly adapts to changing workload phases (e.g., MILC, omnetpp), preserves temporal locality in irregular codes (mcf, astar), and avoids pollution in streaming/stencil patterns (lbm).",ChampSim_CRC2/new_policies/043_adaptive_reuse_phase_replacement__arpr.cc,0.35229620229772485,0.35229620229772485
astar,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.4354730400147415,0.4354730400147415
lbm,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.4372945444635588,0.4372945444635588
mcf,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.46727070086226885,0.46727070086226885
milc,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.24448394968753848,0.24448394968753848
omnetpp,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.6408849335822632,0.6408849335822632
all,Fine-Grained Adaptive RRIP (FG-RRIP),"FG-RRIP employs a 2-bit per-PC signature predictor to classify each incoming line into one of four reuse-probability classes, mapping them to insertion priorities RRPV=0…3 for very hot to very cold. A lightweight epoch-based bias (–1,0,+1) then nudges these priorities to be more or less aggressive depending on recent hit-rate trends. Pointer-chasing workloads (MCF, ASTAR) get strong MRU insertion, stencil codes (LBM) receive moderate priority to exploit spatial locality without polluting, and streaming or one-time lines are relegated to be evicted early. Dynamic bias adaptation lets FG-RRIP react quickly to phase changes (MILC, OMNeT++) and avoid long-term mis-insertion.",ChampSim_CRC2/new_policies/044_fine_grained_adaptive_rrip__fg_rrip.cc,0.44508143372207415,0.44508143372207415
astar,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.447305241746871,0.447305241746871
lbm,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.4293946763311538,0.4293946763311538
mcf,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.40223464469849807,0.40223464469849807
milc,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.24079813464448901,0.24079813464448901
omnetpp,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.4507816833779697,0.4507816833779697
all,Dynamic Insertion Policy (DIP),"We employ set‐dueling to dynamically choose between LRU‐style insertion (best for high temporal locality) and Bimodal RRIP insertion (best for streaming/pointer-chasing), driven by a global saturating PSEL counter. A small number of “LRU” and “BIP” sample sets bias PSEL based on misses; the remaining follower sets then adopt whichever policy yields fewer misses. This lets us adapt online to all five workloads—promoting reuse‐heavy lines in MILC/LBM, demoting one-time lines in MCF/ASTAR, and reacting to phase changes in OMNETPP—while keeping metadata overhead low.",ChampSim_CRC2/new_policies/045_dynamic_insertion_policy__dip.cc,0.39410287615979633,0.39410287615979633
astar,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.46080383846688117,0.46080383846688117
lbm,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.4410822902433393,0.4410822902433393
mcf,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.4052821528744876,0.4052821528744876
milc,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.319912814905465,0.319912814905465
omnetpp,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.13261635917899897,0.13261635917899897
all,SHiP (Signature-based Hit Predictor),"We implement a low‐overhead Signature History Counter Table (SHCT) to predict which load PCs generate temporal reuse versus streaming/pointer‐chasing accesses. Each cache block carries a small signature tagging the PC that brought it in. On a miss, we index the SHCT with that signature: if its saturating counter is above a threshold, we insert the new block as “hot” (RRPV=0), otherwise as “cold” (RRPV=MAX). On a hit, we promote the block (RRPV=0) and increment its signature counter; on eviction of a block that was promoted but never reused, we decrement its counter. This filters out one‐time, streaming lines in ASTAR/MCF/OMNETPP, while favoring reuse‐heavy lines in LBM/MILC and quickly adapting to phase changes, yielding higher overall hit rates.",ChampSim_CRC2/new_policies/046_ship__signature_based_hit_predictor.cc,0.35193949113383444,0.35193949113383444
astar,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.4324086804915732,0.4324086804915732
lbm,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.4100004352787771,0.4100004352787771
mcf,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.404901675082241,0.404901675082241
milc,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.32159098314952533,0.32159098314952533
omnetpp,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.5711985016492594,0.5711985016492594
all,Dynamic Insertion Policy (DIP),"We implement the classic Dynamic Insertion Policy (DIP) over SRRIP by using set dueling to choose at runtime between LRU‐style insertion (always insert as MRU) and Bimodal RRIP insertion (most inserts near eviction age, occasional MRU). A small number of “leader” sets are forced to each policy to update a global PSEL counter on misses, and the remaining “follower” sets pick the better policy based on PSEL. LRU insertion preserves recency for pointer‐chasing and irregular workloads (MCF, OMNETPP, ASTAR), while Bimodal insertion curbs pollution from streaming or one‐time scans (LBM, MILC). Phase changes are automatically tracked by PSEL adjustments, and the policy needs only 2‐bit RRPVs plus one global counter.",ChampSim_CRC2/new_policies/047_dynamic_insertion_policy__dip.cc,0.42802005513027525,0.42802005513027525
astar,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.4593819543863131,0.4593819543863131
lbm,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.4389521515072947,0.4389521515072947
mcf,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.45889482536509096,0.45889482536509096
milc,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.32005583032216484,0.32005583032216484
omnetpp,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.45318548651663276,0.45318548651663276
all,SHIP-RRIP,"We integrate a lightweight Signature-based Hit Predictor (SHIP) with RRIP to adapt insertion to workload-specific reuse. Each block carries a PC-derived signature and a hit flag. A small saturating counter table per signature learns which PCs generate high-reuse blocks (pointer-chasing in MCF/OMNETPP/ASTAR) versus one-shot streams (LBM). On fill, we consult the signature counter: high-reuse signatures yield MRU insertion (RRPV=0), low-reuse signatures yield near-eviction insertion (RRPV=RRPV_MAX-1). Hits always reset RRPV to 0 and mark the block as reused. On eviction, the signature counter is updated up or down based on whether the block was ever hit. This dynamic, per-signature insertion tuning handles irregular access, streaming phases, and phase changes (MILC), boosting hit rates across all workloads.",ChampSim_CRC2/new_policies/048_ship_rrip.cc,0.42609404961949926,0.42609404961949926
astar,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.42438854554990146,0.42438854554990146
lbm,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.402441724688066,0.402441724688066
mcf,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.4596034246757668,0.4596034246757668
milc,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.3029953583350833,0.3029953583350833
omnetpp,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.4376233962219134,0.4376233962219134
all,DRRIP (Dynamic Re-Reference Interval Prediction),"This policy implements dynamic set dueling between two RRIP insertion schemes—static RRIP (SRRIP) and bimodal RRIP (BRRIP)—using a global PSEL counter that is updated on misses in small leader sets. SRRIP favors mid‐range insertion (retain blocks longer), while BRRIP biases new blocks toward far‐LRU (quick eviction) with a small chance of mid‐range insertion. By monitoring which scheme yields fewer misses on dedicated leader sets, DRRIP adaptively chooses the best insertion policy for follower sets. This allows the cache to automatically favor eviction of streaming data, retain high‐reuse blocks, and respond to phase changes in workloads like MILC, yielding higher overall hit rates across diverse access patterns.",ChampSim_CRC2/new_policies/049_drrip__dynamic_re_reference_interval_prediction.cc,0.40541048989414624,0.40541048989414624
astar,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.46261375072644545,0.46261375072644545
lbm,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.43917736096154975,0.43917736096154975
mcf,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.4656503148108193,0.4656503148108193
milc,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.3224689891887586,0.3224689891887586
omnetpp,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.4531735569725203,0.4531735569725203
all,SHiP-RRIP,"This policy augments SRRIP with a lightweight Signature-based Hit Predictor (SHiP): each block’s insertion priority is driven by a per‐PC saturating counter (the SHCT). Blocks touched by PCs with high historical reuse are given RRPV=0 (MRU), while others use a default mid‐range RRPV (RRPV_MAX−1). On a cache hit the block is promoted to MRU and its PC counter is incremented; when a block is evicted without any intervening hits, its PC counter is decremented. By biasing the cache to retain truly hot data and evict streaming or one‐time blocks quickly, SHiP‐RRIP adapts to both temporal‐ and spatial‐heavy phases, pointer‐chasing behaviors, and irregular workloads, improving hit rates over DRRIP across diverse applications.",ChampSim_CRC2/new_policies/050_ship_rrip.cc,0.4286167945320186,0.4286167945320186
astar,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.36694354278586516,0.36694354278586516
lbm,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.39874677799688873,0.39874677799688873
mcf,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.45952600951175376,0.45952600951175376
milc,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.06648225522639883,0.06648225522639883
omnetpp,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.5365073873701917,0.5365073873701917
all,TriSHiP,"TriSHiP extends SHiP‐RRIP by introducing a third insertion priority (LRU, mid‐range, MRU) based on a PC‐indexed reuse predictor, effectively providing light bypass for cold blocks, retention for moderately reused streaming blocks, and strong promotion for hot data. Counters (SHCT) now distinguish “never reused” (counter=0 → insert at LRU), “occasionally reused” (0<counter≤threshold → insert at mid-RRPV), and “frequently reused” (counter>threshold → insert at MRU). This tri‐modal insertion sharply reduces pollution from one‐time or streaming accesses (mcf, omnetpp) while still accommodating spatially heavy stencils (lbm) and phase‐changing workloads (milc, astar), improving overall hit rates.",ChampSim_CRC2/new_policies/051_triship.cc,0.3656411945782196,0.3656411945782196
astar,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.23071730286751052,0.23071730286751052
lbm,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.11616309768260487,0.11616309768260487
mcf,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.36417219962648145,0.36417219962648145
milc,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.08724302483037286,0.08724302483037286
omnetpp,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.24913957136636664,0.24913957136636664
all,DRRIP (Dynamic Re-Reference Interval Prediction),"DRRIP dynamically chooses between two insertion policies—Static RRIP (SRRIP) and Bimodal Insertion (BIP)—using set dueling and a global saturating counter (PSEL). A small fraction of “sample” sets are dedicated to each policy, and PSEL is adjusted based on misses in those sets. All other “follower” sets select SRRIP or BIP according to PSEL’s value. This allows the cache to adapt at runtime: it favors SRRIP when blocks exhibit temporal or spatial locality (e.g., lbm, milc, astar) and switches to BIP to minimize pollution from one-shot or streaming accesses (e.g., mcf, omnetpp). The result is robust performance across diverse workloads and phase behaviors.",ChampSim_CRC2/new_policies/052_drrip__dynamic_re_reference_interval_prediction.cc,0.20948703927466727,0.20948703927466727
astar,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.35481544741952403,0.35481544741952403
lbm,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.44075299300905757,0.44075299300905757
mcf,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.5219687496716299,0.5219687496716299
milc,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.2209733013751204,0.2209733013751204
omnetpp,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.5303040244317063,0.5303040244317063
all,SHiP (Signature-based Hit Predictor),"SHiP uses a lightweight per‐PC signature table to predict whether an incoming block is likely to be reused or will stream through the cache. Each load or instruction fetch’s PC is hashed into a small saturating‐counter table. On a cache hit, SHiP increments the counter for that PC, reinforcing its “reuse” status and inserting future blocks from that PC with a low RRPV (kept longer). On eviction, SHiP decrements the counter of the evicted block’s PC signature, penalizing streaming or one‐shot patterns. This simple runtime‐learned classifier effectively retains high‐locality blocks (e.g., lbm, milc) and quickly evicts unusable data from pointer-chasing or irregular workloads (e.g., mcf, omnetpp), adapting to phase changes and improving overall hit rates compared to DRRIP’s purely interval‐based approach.",ChampSim_CRC2/new_policies/053_ship__signature_based_hit_predictor.cc,0.41376290318140774,0.41376290318140774
astar,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.2449095664006577,0.2449095664006577
lbm,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.11907902580824645,0.11907902580824645
mcf,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.3653809915103268,0.3653809915103268
milc,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.0927409719255306,0.0927409719255306
omnetpp,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.1024628543820198,0.1024628543820198
all,DRRIP,"We implement Dynamic Re-Reference Interval Prediction (DRRIP), which uses set dueling to adaptively choose between Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) insertion policies. A small number of “leader” sets are permanently assigned to SRRIP or BRRIP and their miss counts drive a global PSEL counter. All other “follower” sets use the policy favored by PSEL. SRRIP favors moderate reuse by inserting new blocks with near-MRU priority, while BRRIP aggressively evicts one-shot/streaming data, only occasionally treating a faction of new blocks as reusable. By dynamically selecting the best policy per workload phase, DRRIP preserves high-locality data in reuse-heavy phases (e.g., LBM, MILC) and swiftly evicts streaming or pointer-chasing data (e.g., MCF, Omnet++), yielding robust hit-rate improvements across diverse behaviors.",ChampSim_CRC2/new_policies/054_drrip.cc,0.18491468200535627,0.18491468200535627
astar,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.4357795645579668,0.4357795645579668
lbm,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.4138051764207148,0.4138051764207148
mcf,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.45967504665407616,0.45967504665407616
milc,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.31256290868013065,0.31256290868013065
omnetpp,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.45371635122963777,0.45371635122963777
all,SHiP,"We implement the Signature-based Hit Predictor (SHiP) on top of RRIP: each block carries a PC-derived signature and a reference bit, and a small Signature History Counter Table (SHCT) tracks reuse tendency per signature. On insertion, we look up the SHCT entry for the new block’s signature; if the counter is high, we insert at RRPV=0 (retain), otherwise at RRPV=MAX−1 (evict soon). On eviction, we update the SHCT counter up or down depending on whether that block was ever re-referenced. Hits reset a block’s RRPV to 0 and set its reference bit. This lets us adaptively retain hot streaming/stencil data (LBM, MILC), swiftly evict one‐time/pointer‐chasing blocks (MCF, omnetpp), and track phase changes, yielding robust hit‐rate improvements across diverse workloads.",ChampSim_CRC2/new_policies/055_ship.cc,0.4151078095085053,0.4151078095085053
astar,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.448677514918709,0.448677514918709
lbm,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.4340843497762091,0.4340843497762091
mcf,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.4001370212312857,0.4001370212312857
milc,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.31816223379218955,0.31816223379218955
omnetpp,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.45531491014070896,0.45531491014070896
all,Dynamic RRIP (DRRIP),"DRRIP applies dynamic set dueling to choose between two RRIP‐based insertion styles—strict LRU insertion for high‐reuse data and bimodal insertion (mostly LRU with rare MRU) to filter streaming or thrashing data. Two small groups of “sample” sets each permanently use one insertion style and drive a global PSEL counter based on hits; the remaining “follower” sets then adopt whichever style the counter favors. This lets the cache automatically favor MRU insertion when workloads exhibit temporal locality (ASTAR, MILC) and bias toward near‐LRU insertion to avoid pollution from one‐time or pointer‐chasing accesses (LBM, MCF, omnetpp), while adapting seamlessly to phase changes.",ChampSim_CRC2/new_policies/056_dynamic_rrip__drrip.cc,0.4112752059718205,0.4112752059718205
astar,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.43950658407631576,0.43950658407631576
lbm,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.4130227840052082,0.4130227840052082
mcf,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.4627754703459793,0.4627754703459793
milc,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.31174826390146054,0.31174826390146054
omnetpp,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.5366266828113163,0.5366266828113163
all,SHiP-RRIP,"This policy combines RRIP’s re-reference interval tracking with a per-PC Signature History Counter Table (SHCT) to predict which blocks will be reused. On every block hit, its insertion signature counter is incremented and the block is promoted to MRU. On block eviction, its signature counter is decremented. On a miss, the incoming block’s signature counter is consulted: if the counter indicates past reuse, the block is inserted as MRU; otherwise it is inserted near-LRU. Replacement still uses SRRIP’s RRPV-based victim search and aging. This approach filters out one-time or streaming blocks (e.g., LBM, MCF, omnetpp), retains highly reused blocks (e.g., astar, milc), and adapts quickly to phase changes by learning reuse at the granularity of dynamic instruction signatures.",ChampSim_CRC2/new_policies/057_ship_rrip.cc,0.432735957028056,0.432735957028056
astar,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.43745924818211457,0.43745924818211457
lbm,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.40878320196065443,0.40878320196065443
mcf,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.472786842525576,0.472786842525576
milc,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.24771537397626306,0.24771537397626306
omnetpp,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.5145510614311875,0.5145510614311875
all,SHiP-DRRIP,"This policy combines SHiP’s PC‐based reuse prediction with Dynamic RRIP’s adaptive bimodal insertion (set‐dueling). Blocks whose signatures indicate high reuse are inserted at MRU, while blocks predicted as non‐reusable are inserted according to a DRRIP scheme: two sample sets (SRRIP and BRRIP) update a global saturating PSEL counter based on misses, and follower sets choose between SRRIP (near‐LRU) or BRRIP (far‐LRU with rare MRU) insertions. This synergy retains true reuse, aggressively evicts streaming or thrashing blocks, and dynamically adapts to workload characteristics and phase changes, improving hit rates across all five benchmarks.",ChampSim_CRC2/new_policies/058_ship_drrip.cc,0.4162591456151591,0.4162591456151591
astar,SHiP-GRRIP,"SHiP-GRRIP marries PC-based reuse prediction (as in SHiP) with a multi-level RRIP insertion scheme to grant finer control over a block’s cache “time-to-live.” We use a 3-bit RRPV (0–7) and a PC-indexed saturating counter (SHCT) to predict temporal reuse strength in four grades. On a miss, we compute the block’s signature and look up its SHCT counter (0–3), then insert the block with RRPVinit = 7 – (SHCT × 2), yielding insertion priorities of {7,5,3,1}. Highly reusable blocks (SHCT=3) are inserted near MRU (1), while streaming or thrashing PCs (SHCT=0) land at far-LRU (7). Hits always reset RRPV→0 and reinforce SHCT; evictions decrement it. This granular scheme adapts continuously to workload phase shifts, retains stencil/data-local blocks longer (LBM, MILC), and evicts control-dominated or pointer-chasing blocks (ASTAR, MCF, OMNETPP) more aggressively, boosting overall hit rates without complex set-dueling.",ChampSim_CRC2/new_policies/059_ship_grrip.cc,0.3102985159251017,0.3102985159251017
lbm,SHiP-GRRIP,"SHiP-GRRIP marries PC-based reuse prediction (as in SHiP) with a multi-level RRIP insertion scheme to grant finer control over a block’s cache “time-to-live.” We use a 3-bit RRPV (0–7) and a PC-indexed saturating counter (SHCT) to predict temporal reuse strength in four grades. On a miss, we compute the block’s signature and look up its SHCT counter (0–3), then insert the block with RRPVinit = 7 – (SHCT × 2), yielding insertion priorities of {7,5,3,1}. Highly reusable blocks (SHCT=3) are inserted near MRU (1), while streaming or thrashing PCs (SHCT=0) land at far-LRU (7). Hits always reset RRPV→0 and reinforce SHCT; evictions decrement it. This granular scheme adapts continuously to workload phase shifts, retains stencil/data-local blocks longer (LBM, MILC), and evicts control-dominated or pointer-chasing blocks (ASTAR, MCF, OMNETPP) more aggressively, boosting overall hit rates without complex set-dueling.",ChampSim_CRC2/new_policies/059_ship_grrip.cc,0.27321829378612333,0.27321829378612333
astar,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.4415264567888985,0.4415264567888985
lbm,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.42544147676841465,0.42544147676841465
mcf,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.4101534698132135,0.4101534698132135
milc,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.3088372665590129,0.3088372665590129
omnetpp,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.5580760031255405,0.5580760031255405
all,QL-RRIP,"QL-RRIP augments SRRIP with a per-PC Q-learning table that chooses among three insertion priorities (MRU, mid-age, distant) via ε-greedy action selection. Each PC-derived signature indexes a small Q-table; when a block is evicted, the agent receives a reward of 1 if the block was ever hit, or 0 if it never saw a hit. Q-values are updated by temporal-difference and guide future insertions—allows quick adaptation to phase changes (astar vs. lbm vs. milc), filters one-shot streaming blocks (MCF, omnetpp), and promotes true reuse across diverse patterns.",ChampSim_CRC2/new_policies/000_ql_rrip.cc,0.42880693461101604,0.42880693461101604
astar,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.43872698408198557,0.43872698408198557
lbm,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.359065248288692,0.359065248288692
mcf,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.4409693836448909,0.4409693836448909
milc,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.0761041152233575,0.0761041152233575
omnetpp,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.8383009943275018,0.8383009943275018
all,SMI-RRIP,"SMI-RRIP augments SRRIP with a lightweight signature-based reuse predictor (inspired by SHiP) that learns, per PC signature, whether blocks are frequently reused, moderately reused, or one-shot. A small saturating counter table per signature is updated on evictions based on whether the block saw a hit. On insertion, the counter value selects one of three RRPV insertion priorities: MRU for highly reused, mid-age for moderate reuse, and distant for likely streaming. This filters out one-shot blocks (beneficial for MCF/omnetpp), retains hot blocks (beneficial for astar/milc), and provides mid-level retention for regular stencils (lbm), quickly adapting to phase changes at very low overhead.",ChampSim_CRC2/new_policies/001_smi_rrip.cc,0.4306333451132856,0.4306333451132856
astar,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.42904665551602433,0.42904665551602433
lbm,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.40727521163064895,0.40727521163064895
mcf,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.4609941100980156,0.4609941100980156
milc,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.3082543429618312,0.3082543429618312
omnetpp,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.846753076331188,0.846753076331188
all,DRRIP,"DRRIP (Dynamic RRIP) combines Static RRIP (SRRIP) and Bimodal RRIP (BRRIP) via set‐dueling to automatically adapt to streaming, high‐reuse, and phase‐changing workloads. A small fraction of “leader” sets always use SRRIP or BRRIP insertion; their miss outcomes drive a global saturating counter (PSEL). Follower sets consult PSEL to choose between SRRIP’s near‐reuse insertion (protecting blocks in lbm/milc/astar) and BRRIP’s largely distant insertion (filtering one‐shot blocks in mcf/omnetpp). This lightweight dynamic policy balances retention and eviction to improve hit rates across all five workloads.",ChampSim_CRC2/new_policies/002_drrip.cc,0.4904646793075417,0.4904646793075417
astar,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.32211239892875776,0.32211239892875776
lbm,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.2532253333207165,0.2532253333207165
mcf,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.4345361770808669,0.4345361770808669
milc,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.07428112124086693,0.07428112124086693
omnetpp,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.8396311384960424,0.8396311384960424
all,SHiP-RRIP,"We integrate the SHiP (Signature‐based Hit Predictor) mechanism with SRRIP’s replacement to adaptively filter thrashing blocks and retain reusable ones. A small Signature History Table (SHT) tracks whether blocks brought in by a given PC are typically re‐referenced: on eviction, we increment or decrement the PC’s counter based on whether the block was reused. On each miss, we hash the PC to index the SHT; if the counter predicts reuse, we insert the block with a “near” RRPV, otherwise with a “far” RRPV. Hits always reset RRPV to 0 and mark the block as reused. This approach filters one‐shot pointer‐chasing accesses (MCF, Omnet++) while boosting spatially or temporally reusable lines (LBM, MILC, A*), and adapts to phase changes via dynamic counters.",ChampSim_CRC2/new_policies/003_ship_rrip.cc,0.38475723381345006,0.38475723381345006
astar,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.43777679146479,0.43777679146479
lbm,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.3665513495509067,0.3665513495509067
mcf,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.4615321029322551,0.4615321029322551
milc,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.07457258303945777,0.07457258303945777
omnetpp,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.8373168069382229,0.8373168069382229
all,3-Level SHiP-RRIP,"We extend SHiP‐RRIP by introducing three insertion priorities—far, medium, and near—based on a PC‐signature counter that dynamically tracks expected reuse. Lines from PCs with low reuse history are inserted with a far RRPV so they age out quickly, those with moderate reuse get a medium RRPV to balance retention and eviction, and highly reusable lines are inserted at RRPV=0 to maximize their residency. This granular control further reduces pollution from one‐shot pointer‐chasing streams (MCF, Omnet++), retains spatially streaming data just long enough for reuse (LBM, MILC), and adapts seamlessly to phase changes in irregular workloads (A*), yielding higher hit rates across heterogeneous benchmarks.",ChampSim_CRC2/new_policies/004_3_level_ship_rrip.cc,0.4355499267851265,0.4355499267851265
astar,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.42956402642135255,0.42956402642135255
lbm,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.40423961528926167,0.40423961528926167
mcf,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.45996989169275515,0.45996989169275515
milc,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.3031311324648617,0.3031311324648617
omnetpp,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.8385037965774138,0.8385037965774138
all,Dynamic Insertion Policy (DIP),"DIP uses set dueling to dynamically choose between bimodal insertion (BIP) and static RRIP (SRRIP) policies based on runtime misses in dedicated leader sets. BIP mostly inserts new lines with a long re‐reference period (far RRPV) to avoid polluting the cache with one‐shot or streaming accesses, while SRRIP inserts at a moderate re‐reference period (near RRPV) to favor temporal reuse. By monitoring misses in small groups of “BIP‐leader” and “SRRIP‐leader” sets, DIP steers a global counter (PSEL) to select the best insertion policy for the majority of sets. This mechanism adapts to workloads ranging from pointer‐chasing (MCF, omnetpp) to streaming stencils (LBM) and mixed‐phase codes (MILC, A*), yielding robust hit‐rate improvements across all benchmarks.",ChampSim_CRC2/new_policies/005_dynamic_insertion_policy__dip.cc,0.487081692489129,0.487081692489129
astar,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.2968814228408624,0.2968814228408624
lbm,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.2272409844907692,0.2272409844907692
mcf,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.4103136735964828,0.4103136735964828
milc,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.06438771298435157,0.06438771298435157
omnetpp,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.8541195698206393,0.8541195698206393
all,Signature-Based Insertion Policy (SHiP),"We employ a per‐PC, 2-bit saturating counter table to predict whether blocks brought in by a given instruction PC will be reused. On each cache miss, we evict a victim and update its PC counter based on whether it saw any cache hits while resident (decrement if never reused, increment if reused). For the incoming block, we hash its PC to index the predictor table; if the counter predicts “reuse,” we insert with a mid‐priority RRPV (favoring retention), otherwise we insert with a long re‐reference RRPV (evict early). Hits reset RRPV to zero and mark the block as reused. This lightweight, per‐PC adaptation differentiates streaming or “one‐shot” accesses from temporal reuse, adapting to phase changes and diverse patterns in A*, LBM, MCF, MILC, and Omnet++, yielding higher hit rates than global schemes like DIP.",ChampSim_CRC2/new_policies/006_signature_based_insertion_policy__ship.cc,0.37058867274662105,0.37058867274662105
astar,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.43822024408567095,0.43822024408567095
lbm,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.36291273417525083,0.36291273417525083
mcf,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.4169398130018823,0.4169398130018823
milc,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.06438771298435157,0.06438771298435157
omnetpp,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.8526164472624679,0.8526164472624679
all,TriSHiP,"TriSHiP augments the original SHiP idea with a three-level insertion priority based on a per-PC 2-bit saturating counter. Each new block is classified as heavy-reuse, moderate-reuse, or low-reuse (streaming) and inserted with RRPV=0 (LRU), RRPV=MAX−1 (SRRIP), or RRPV=MAX (BIP) respectively. Blocks mispredicted as streaming still occupy minimal resources, while genuinely hot data (e.g., stencil phases in LBM or MILC) are retained aggressively. This tri-threshold approach handles pointer-chasing workloads (MCF, Omnet++, A*) by early eviction of dead lines, adapts to phase changes, and maximizes retention of recurrent data, yielding superior hit rates across diverse patterns.",ChampSim_CRC2/new_policies/007_triship.cc,0.42701539030192465,0.42701539030192465
astar,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.4371961331840281,0.4371961331840281
lbm,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.36283703351835833,0.36283703351835833
mcf,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.4177958544337272,0.4177958544337272
milc,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.06438771298435157,0.06438771298435157
omnetpp,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.8526045177183554,0.8526045177183554
all,DynaSHiP,"DynaSHiP builds on SHiP’s PC-based tri-level insertion by adding a lightweight set-dueling mechanism that dynamically adapts how “moderate-reuse” blocks are placed in the RRPV hierarchy. We reserve two small groups of dueling sets: one always inserting moderate blocks as LRU (RRPV=0) and one always as SRRIP (RRPV=MAX-1). Misses in those sets update a global saturating PSEL counter, which then guides the insertion of moderate blocks in all other sets—leaning toward LRU or SRRIP based on which dueling policy currently yields fewer misses. Heavy-reuse and streaming blocks follow the original SHiP hot/cold classification. This dynamic choice for the middle class lets DynaSHiP flexibly optimize for high temporal locality (e.g., LBM, MILC) or pointer-chasing/streaming scenarios (e.g., MCF, omnetpp, A*) and react quickly to phase changes.",ChampSim_CRC2/new_policies/008_dynaship.cc,0.4269642503677641,0.4269642503677641
astar,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.4377046449985117,0.4377046449985117
lbm,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.3629108416588285,0.3629108416588285
mcf,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.4177958544337272,0.4177958544337272
milc,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.06438771298435157,0.06438771298435157
omnetpp,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.8526045177183554,0.8526045177183554
all,TriDIP,"TriDIP extends SHiP’s PC‐based reuse classification and DynaSHiP’s dynamic moderate‐reuse insertion by adding a third insertion policy, Bimodal Insertion (BIP), to better handle streaming and misclassified blocks. We partition cache sets into two small dueling windows: the first duels LRU vs SRRIP for moderate‐reuse blocks, the second duels SRRIP vs BIP. Two 10‐bit PSEL counters track which policy in each duel yields fewer misses. Heavy‐reuse blocks always insert as MRU, low‐reuse blocks always near‐evict (SRRIP), and moderate‐reuse blocks in non‐duel sets choose LRU, SRRIP, or BIP based on PSEL1 and PSEL2. BIP occasionally inserts MRU with low probability to rescue streaming or pointer‐chasing blocks. This ternary policy adapts quickly to phase changes and covers workloads from high spatial‐locality stencils to irregular pointer chains.",ChampSim_CRC2/new_policies/009_tridip.cc,0.42708071435875483,0.42708071435875483
astar,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.31362067499184965,0.31362067499184965
lbm,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.1658658168006253,0.1658658168006253
mcf,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.4103136735964828,0.4103136735964828
milc,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.06435874783666554,0.06435874783666554
omnetpp,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.8530459108505168,0.8530459108505168
all,StrideAwareSHiP,"StrideAwareSHiP extends the SHiP temporal‐reuse predictor with a lightweight per‐PC stride detector to identify spatial streaming patterns (e.g., stencil codes) and avoid polluting the cache with blocks that exhibit constant address strides but little temporal reuse. We maintain two tables indexed by a PC signature: a 3-bit SHiP counter for temporal reuse classification (heavy, moderate, low) and a small stride‐run counter for spatial pattern detection. On insertion, streaming blocks are near‐evicted (MAX_RRPV) while temporally heavy blocks go to MRU (RRPV=0) and moderate blocks to near‐MRU (RRPV=MAX_RRPV–1). Hits always promote to MRU. This hybrid strategy preserves useful temporal locality in irregular workloads (MCF, A*) and QCD codes (MILC) while bypassing or quickly evicting pure spatial streams (LBM, Omnet++), improving overall hit rate.",ChampSim_CRC2/new_policies/010_strideawareship.cc,0.361440964815228,0.361440964815228
astar,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.4525232462543764,0.4525232462543764
lbm,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.4355172342007998,0.4355172342007998
mcf,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.4096460657431569,0.4096460657431569
milc,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.24505601135433788,0.24505601135433788
omnetpp,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.8260493525239933,0.8260493525239933
all,SetDuelDIP,"SetDuelDIP applies Dynamic Insertion Policy (DIP) on top of SRRIP with set‐dueling to adaptively choose between LRU and Bimodal Insertion (BIP). Two small leader sets sample pure LRU and pure BIP on misses and update a global PSEL counter: misses in the LRU leader decrement PSEL (punishing LRU), and misses in the BIP leader increment PSEL (punishing BIP). All other “follower” sets use the preferred policy indicated by PSEL—LRU insertion for temporally‐reused blocks, BIP near‐eviction for streaming patterns—while always promoting hits to MRU. This workload‐agnostic adaptation balances spatial and temporal locality, quickly evicting pure streams (LBM, omnetpp) and retaining useful blocks in pointer‐chasing and branching codes (MCF, astar, milc), improving overall hit rate.",ChampSim_CRC2/new_policies/011_setdueldip.cc,0.4737583820153328,0.4737583820153328
astar,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.4088815929354066,0.4088815929354066
lbm,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.4393325473081793,0.4393325473081793
mcf,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.3775077303735378,0.3775077303735378
milc,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.1537886413173349,0.1537886413173349
omnetpp,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.8375613625925286,0.8375613625925286
all,SHiP-RRIP,"We integrate a Signature-based Hit Predictor (SHiP) with SRRIP to automatically learn which load PCs generate reusable blocks and which are streaming one-offs. A small Signature History Counter Table (SHCT) indexed by a PC-derived signature tracks if blocks brought in by that PC were ever hit before eviction. On eviction, we increment/decrement the SHCT entry based on whether the block saw a hit. On new insertions, if the SHCT entry is positive we insert at MRU (RRPV=0), otherwise at near-eviction (RRPV=MAX). Hits always promote to MRU and set a per-block reuse flag. This per-PC adaptation retains truly reusable blocks (pointer-chasing, phase-based reuse) while quickly evicting pure streams (stencils, one-time traversals), improving hit rate across all workloads.",ChampSim_CRC2/new_policies/012_ship_rrip.cc,0.4434143749053974,0.4434143749053974
astar,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.4395512689330013,0.4395512689330013
lbm,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.4316821789635843,0.4316821789635843
mcf,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.4590171628721541,0.4590171628721541
milc,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.15303735779922809,0.15303735779922809
omnetpp,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.8406869031499962,0.8406869031499962
all,Tri-Insert-RRIP,"We introduce a three-level PC-based insertion policy combined with SRRIP: a small PC Counter Table (PCCT) tracks per-PC reuse likelihood via saturating counters updated on block hits and evictions. On new fills, blocks are classified as streaming (low reuse), moderate reuse, or heavy reuse based on PCCT thresholds and inserted with RRPV = MAX (near eviction), RRPV = 1, or RRPV = 0 (MRU) respectively. Hits always reset RRPV to 0. This tri-level scheme preserves heavily reused blocks, gives moderate-reuse blocks a fair chance (beneficial for mixed-phase workloads like MILC), and swiftly ejects streaming data (e.g., stencils in LBM), yielding higher overall hit rates across irregular, regular, and phase-varying workloads.",ChampSim_CRC2/new_policies/013_tri_insert_rrip.cc,0.46479497434359274,0.46479497434359274
astar,DIP-PC-RRIP,"We combine per‐PC reuse tracking with a global dynamic insertion policy (DIP).  A small PC Counter Table (PCCT) classifies blocks at fill into three classes: “heavy‐reuse” PCs (always inserted as MRU), “streaming” PCs (always near eviction), and “moderate‐reuse” PCs.  Moderate‐reuse blocks are managed by a global PSEL saturating counter that steers between SRRIP (insertion at RRPV=MAX–1) and BRRIP (insertion usually at MAX but with occasional MRU) based on which yielded more hits in past epochs.  Hits on moderate blocks update PSEL to favor the better policy.  Evicted blocks update their PCCT counters based on whether they were ever hit.  This hybrid keeps truly hot data, quickly ejects one‐time streams, and dynamically tunes midsize reuse to workload phase, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/014_dip_pc_rrip.cc,0.4281354343571794,0.4281354343571794
lbm,DIP-PC-RRIP,"We combine per‐PC reuse tracking with a global dynamic insertion policy (DIP).  A small PC Counter Table (PCCT) classifies blocks at fill into three classes: “heavy‐reuse” PCs (always inserted as MRU), “streaming” PCs (always near eviction), and “moderate‐reuse” PCs.  Moderate‐reuse blocks are managed by a global PSEL saturating counter that steers between SRRIP (insertion at RRPV=MAX–1) and BRRIP (insertion usually at MAX but with occasional MRU) based on which yielded more hits in past epochs.  Hits on moderate blocks update PSEL to favor the better policy.  Evicted blocks update their PCCT counters based on whether they were ever hit.  This hybrid keeps truly hot data, quickly ejects one‐time streams, and dynamically tunes midsize reuse to workload phase, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/014_dip_pc_rrip.cc,0.3379201623022084,0.3379201623022084
mcf,DIP-PC-RRIP,"We combine per‐PC reuse tracking with a global dynamic insertion policy (DIP).  A small PC Counter Table (PCCT) classifies blocks at fill into three classes: “heavy‐reuse” PCs (always inserted as MRU), “streaming” PCs (always near eviction), and “moderate‐reuse” PCs.  Moderate‐reuse blocks are managed by a global PSEL saturating counter that steers between SRRIP (insertion at RRPV=MAX–1) and BRRIP (insertion usually at MAX but with occasional MRU) based on which yielded more hits in past epochs.  Hits on moderate blocks update PSEL to favor the better policy.  Evicted blocks update their PCCT counters based on whether they were ever hit.  This hybrid keeps truly hot data, quickly ejects one‐time streams, and dynamically tunes midsize reuse to workload phase, improving hit rates across irregular, streaming, and phase‐changing workloads.",ChampSim_CRC2/new_policies/014_dip_pc_rrip.cc,0.4231158559864939,0.4231158559864939
astar,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.20866082439155764,0.20866082439155764
lbm,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.10323148402236963,0.10323148402236963
mcf,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.4076006509359481,0.4076006509359481
milc,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.09320803493196811,0.09320803493196811
omnetpp,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.01513859147872664,0.01513859147872664
all,SigDIP-RRIP,"We combine a lightweight, PC‐signature‐based reuse predictor (SHiP) with a bimodal insertion policy (BIP) via two tiny “leader” regions and a global policy selector (PSEL). A small fraction of sets always insert using SHiP, and another small fraction always insert using BIP; misses in those leader sets increment or decrement PSEL to “punish” the worse policy. All remaining “follower” sets consult PSEL to choose between SHiP-guided insertion (favoring blocks whose PC signatures have proven high-reuse) or BIP (filtering one-shot and streaming data). Hits are always promoted to MRU, and on every eviction we train the SHiP signature table by rewarding or punishing the PC signature of the evicted block. This dynamic two-way dueling steers between fine-grained, phase‐aware PC reuse prediction (boosting hit rates on ASTAR, MILC) and robust streaming filtering (LBM, MCF, OMNETPP), and can outperform pure DRRIP, DIP, Tri-RRIP and SHiP-RRIP on a mix of control-, compute-, and memory-bound workloads.",ChampSim_CRC2/new_policies/000_sigdip_rrip.cc,0.16556791715211402,0.16556791715211402
astar,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.41570397879488014,0.41570397879488014
lbm,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.4395966676633901,0.4395966676633901
mcf,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.5269464769196821,0.5269464769196821
milc,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.30864718277732317,0.30864718277732317
omnetpp,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.01576508061485604,0.01576508061485604
all,FreqRRIP,"FreqRRIP combines a lightweight PC-based frequency estimator with SRRIP eviction to quickly distinguish hot, reusable data from one-shot or streaming accesses. A small per-PC counter table tracks how often each load‐PC’s blocks are actually reused: counters increment on hits and decrement on evictions when no hit followed. On a fill, if the PC’s counter exceeds a low threshold the block is inserted at MRU (RRPV=0); otherwise it is given the farthest re-reference prediction (RRPV=MAX) effectively bypassing low-reuse data. Hits always promote to MRU and boost the PC counter. This simple scheme avoids expensive set-dueling, adapts rapidly to phase changes, keeps hot control- and compute-bound data (ASTAR, MILC) resident, and bypasses streaming/pointer-chasing traffic (LBM, MCF, OMNETPP), yielding robust hit rates across diverse workloads.",ChampSim_CRC2/new_policies/001_freqrrip.cc,0.34133187735402626,0.34133187735402626
astar,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.46206980254858326,0.46206980254858326
lbm,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.4398567743571595,0.4398567743571595
mcf,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.47727688262997625,0.47727688262997625
milc,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.32414715743281897,0.32414715743281897
omnetpp,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.6041538672599627,0.6041538672599627
all,SA-SHiP,"SA-SHiP (Spatially-Aware Signature-based Hit Predictor) combines a lightweight PC-signature counter (SHiP) with SRRIP, but instead of fully bypassing cold blocks it inserts them at a near-MRU position to capture modest spatial reuse. A small per-PC saturating counter tracks whether loads tend to see reuse: hot signatures insert at MRU (RRPV=0), cold ones at RRPV=RRPV_MAX–1. On hits, blocks are promoted and the counter is increased; on eviction, the counter is updated up or down based on whether the block was ever reused. By avoiding outright bypass, SA-SHiP retains useful spatio-temporal locality in regular stencil codes (LBM, MILC) while still deprioritizing true streaming and pointer-chasing traffic (MCF, OMNETPP), and it adapts quickly to phase changes without heavyweight set-dueling.",ChampSim_CRC2/new_policies/002_sa_ship.cc,0.4615008968457001,0.4615008968457001
astar,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.47107329657401237,0.47107329657401237
lbm,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.44074542295769475,0.44074542295769475
mcf,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.5285058807870938,0.5285058807870938
milc,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.3227188135875508,0.3227188135875508
omnetpp,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.5149029829825054,0.5149029829825054
all,TriSHiP,"TriSHiP (Tri-State Signature-based Hit Predictor) augments SA-SHiP with a third “bypass” state to completely avoid caching true streaming traffic. We classify each PC signature into one of three reuse regimes—streaming (no reuse), moderate reuse, or heavy reuse—by tracking a small per-signature saturating counter. On a miss we insert: streaming blocks at RRPV_MAX (bypassed), moderate blocks at RRPV_MAX–1 (near-MRU), and heavy-reuse blocks at RRPV=0 (MRU). Hits continue to promote blocks to MRU and reinforce their signature. Initial counters start in the heavy-reuse state to quickly capture new temporal patterns, and adapt down on evictions that never see a reuse. This three-state insertion sharply reduces pollution from pointer-chasing and streaming workloads (MCF, OMNETPP), preserves spatial locality in stencil codes (LBM, MILC), and adapts faster to phase changes than vanilla SHiP.",ChampSim_CRC2/new_policies/003_triship.cc,0.4555892793777714,0.4555892793777714
astar,DuTriSHiP (Dueling Tri-State SHiP),"DuTriSHiP combines the three-state signature-based insertion of TriSHiP with a lightweight DRRIP-style set dueling mechanism to adaptively choose between TriSHiP and plain SRRIP. Two small groups of “leader” sets sample TriSHiP and SRRIP respectively, incrementing/decrementing a global saturating counter (PSEL) on misses. The remaining “follower” sets follow whichever policy has fewer misses. This dynamic switching preserves TriSHiP’s bypass benefits on pointer-chasing/streaming workloads while falling back to SRRIP’s simpler near-LRU insertion when TriSHiP’s per-signature machinery hurts workloads with strong spatial locality (e.g., LBM), yielding more robust performance across all benchmarks.",ChampSim_CRC2/new_policies/004_dutriship__dueling_tri_state_ship.cc,0.4339501622985443,0.4339501622985443
lbm,DuTriSHiP (Dueling Tri-State SHiP),"DuTriSHiP combines the three-state signature-based insertion of TriSHiP with a lightweight DRRIP-style set dueling mechanism to adaptively choose between TriSHiP and plain SRRIP. Two small groups of “leader” sets sample TriSHiP and SRRIP respectively, incrementing/decrementing a global saturating counter (PSEL) on misses. The remaining “follower” sets follow whichever policy has fewer misses. This dynamic switching preserves TriSHiP’s bypass benefits on pointer-chasing/streaming workloads while falling back to SRRIP’s simpler near-LRU insertion when TriSHiP’s per-signature machinery hurts workloads with strong spatial locality (e.g., LBM), yielding more robust performance across all benchmarks.",ChampSim_CRC2/new_policies/004_dutriship__dueling_tri_state_ship.cc,0.41260231455634516,0.41260231455634516
mcf,DuTriSHiP (Dueling Tri-State SHiP),"DuTriSHiP combines the three-state signature-based insertion of TriSHiP with a lightweight DRRIP-style set dueling mechanism to adaptively choose between TriSHiP and plain SRRIP. Two small groups of “leader” sets sample TriSHiP and SRRIP respectively, incrementing/decrementing a global saturating counter (PSEL) on misses. The remaining “follower” sets follow whichever policy has fewer misses. This dynamic switching preserves TriSHiP’s bypass benefits on pointer-chasing/streaming workloads while falling back to SRRIP’s simpler near-LRU insertion when TriSHiP’s per-signature machinery hurts workloads with strong spatial locality (e.g., LBM), yielding more robust performance across all benchmarks.",ChampSim_CRC2/new_policies/004_dutriship__dueling_tri_state_ship.cc,0.461952147277943,0.461952147277943
